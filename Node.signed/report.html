<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
<meta name="Submission" content="/tmp/codecheck/18040624173315362060052232749"/>
<meta name="Level" content="1"/>
<meta name="Time" content="2018-04-06T00:17:49Z"/>
<meta name="ID" content="Node"/>
<meta name="User" content="1801310608b6f1wjv9hvt95tlezt0umla91"/>
<meta name="Problem" content="ext/180326075292xpg4lwjt8ir9ctwna56cp98"/>
<meta name="Elapsed" content="16488 ms"/>
<style type="text/css">
.header {font-weight: bold; font-size: 1.2em; }
.item {font-weight: bold;}
.pass {color: green;}
.fail {color: red;}
.note {color: blue; font-weight: bold;}
table.file td {padding-right: 1em; background: #FFF; }
.linenumber {color: gray;}
.footnote {font-size: 0.7em;}
table {font-size: 0.9em;}
td, th { background: #EEE; margin: 0.5em; padding: 0.25em;}
table.output td {vertical-align: top;}
div.footnotes { border-top: 1px solid gray; padding-top: 0.5em; }
</style>
<title>Report</title>
</head>
<body>
<p class="header run">Testing TestDriver.cpp</p>
<div class="run">
<pre class="output">
</pre>
<pre class="output">=======
Prepend
=======
        |--------------------Vector-------------------|  |---------------------List--------------------|
  Size      Time  Creates   Copies     Assigns Destroys      Time  Creates   Copies     Assigns Destroys
   100      0 ms      100      411       4,823      411      0 ms      100      100           0      100
   500      0 ms      500    1,991     124,239    1,991      0 ms      500      500           0      500
 1,000     20 ms    1,000    4,001     498,477    4,001      0 ms    1,000    1,000           0    1,000
 5,000    318 ms    5,000   23,163  12,489,309   23,163      0 ms    5,000    5,000           0    5,000
10,000  1,083 ms   10,000   46,353  49,978,617   46,353      1 ms   10,000   10,000           0   10,000

======
Append
======
        |--------------------Vector-------------------|  |---------------------List--------------------|
  Size      Time  Creates   Copies     Assigns Destroys      Time  Creates   Copies     Assigns Destroys
   100      0 ms      100      227           0      227      0 ms      100      100           0      100
   500      0 ms      500    1,011           0    1,011      0 ms      500      500           0      500
 1,000      0 ms    1,000    2,023           0    2,023      0 ms    1,000    1,000           0    1,000
 5,000      1 ms    5,000   13,191           0   13,191      0 ms    5,000    5,000           0    5,000
10,000      0 ms   10,000   26,383           0   26,383      0 ms   10,000   10,000           0   10,000

===
Get
===
        |--------------------Vector-------------------|  |---------------------List--------------------|
  Size      Time  Creates   Copies     Assigns Destroys      Time  Creates   Copies     Assigns Destroys
   100      0 ms        0   10,000           0   10,000      2 ms        0   10,000           0   10,000
   500      0 ms        0   10,000           0   10,000     20 ms        0   10,000           0   10,000
 1,000      0 ms        0   10,000           0   10,000     27 ms        0   10,000           0   10,000
 5,000      0 ms        0   10,000           0   10,000    134 ms        0   10,000           0   10,000
10,000      1 ms        0   10,000           0   10,000    274 ms        0   10,000           0   10,000

======
Remove
======
        |--------------------Vector-------------------|  |---------------------List--------------------|
  Size      Time  Creates   Copies     Assigns Destroys      Time  Creates   Copies     Assigns Destroys
   100      0 ms        0        0       2,317      100      0 ms        0        0           0      100
   500      0 ms        0        0      61,472      500      0 ms        0        0           0      500
 1,000      1 ms        0        0     242,707    1,000      1 ms        0        0           0    1,000
 5,000     47 ms        0        0   6,167,001    5,000     44 ms        0        0           0    5,000
10,000    165 ms        0        0  24,937,212   10,000    167 ms        0        0           0   10,000

======
Insert
======
        |--------------------Vector-------------------|  |---------------------List--------------------|
  Size      Time  Creates   Copies     Assigns Destroys      Time  Creates   Copies     Assigns Destroys
   100      0 ms      100      411       2,512      411      0 ms      100      100           0      100
   500      1 ms      500    1,985      60,949    1,985      1 ms      500      500           0      500
 1,000      7 ms    1,000    3,989     248,198    3,989      4 ms    1,000    1,000           0    1,000
 5,000    187 ms    5,000   23,147   6,182,005   23,147    132 ms    5,000    5,000           0    5,000
10,000    725 ms   10,000   46,337  25,034,372   46,337    588 ms   10,000   10,000           0   10,000

=======
Reverse
=======
        |--------------------Vector-------------------|  |---------------------List--------------------|
  Size      Time  Creates   Copies     Assigns Destroys      Time  Creates   Copies     Assigns Destroys
   100      0 ms       99      496      14,850      595      0 ms       99      298           0      397
   500      2 ms      499    2,496     374,250    2,995      1 ms      499    1,498           0    1,997
 1,000     12 ms      999    4,996   1,498,500    5,995      5 ms      999    2,998           0    3,997
 5,000    248 ms    4,999   24,996  37,492,500   29,995    132 ms    4,999   14,998           0   19,997
10,000    980 ms    9,999   49,996 149,985,000   59,995    529 ms    9,999   29,998           0   39,997

Done! Total time: 5.89166 seconds
</pre>
</div>
<p class="header studentFiles">Student files</p>
<div class="studentFiles">
<p class="caption">Node.cpp:</p>
<pre>#include &lt;iostream&gt;
#include "Node.h"

using namespace std;

long Node::constructor_count = 0;
long Node::copy_count = 0;
long Node::destructor_count = 0;
long Node::assign_count=0;
/***** Complete this file. *****/
long Node::get_destructor_count()
{
    return destructor_count;
}
long Node::get_copy_count()
{
    return copy_count;
}
long Node::get_constructor_count()
{
    return constructor_count;
}
Node&amp; Node::operator =(const Node&amp; rhs)
{
   value = rhs.value;
   assign_count++;
   return *this;
}


long Node::get_assign_count()
{
   return assign_count;
}
Node::Node(const long the_value)
{
    value = the_value;
    constructor_count++;
}
Node::Node(const Node&amp; other)
{
    this-&gt;value = other.value;
    copy_count++;
}
void Node::reset()
{
    constructor_count=0;
    copy_count=0;
    destructor_count=0;
    assign_count=0;
}
bool Node::operator ==(const Node&amp; other) const
{
    if(value == other.value)
        return true;
    else
        return false;
}
bool Node::operator  &gt;(const Node&amp; other) const
{
    if(value &gt; other.value)
        return true;
    else
        return false;
}
long Node::get_value() const
{
    return value;
}

Node::~Node()
{
    destructor_count++;
}
</pre>
<p class="caption">Node.h:</p>
<pre>#ifndef NODE_H_
#define NODE_H_

/***** Modify this file if necessary. *****/

/**
 * A node for the sorted vector and sorted linked list.
 */
class Node
{
public:
    /**
     * Constructor.
     * @param the_value the initial value.
     */
    Node(const long the_value);

    /**
     * Copy constructor.
     * @param other the other node object to copy.
     */
    Node(const Node&amp; other);
    Node&amp; operator =(const Node&amp; rhs);

    /**
     * Destructor.
     */
    virtual ~Node();

    /**
     * Getter.
     * @return the value.
     */
    long get_value() const;

    /**
     * Getter.
     * @return the value of the global constructor_count.
     */
    static long get_constructor_count();

    /**
     * Getter.
     * @return the value of the global copy_count.
     */
    static long get_copy_count();

    /**
     * Getter.
     * @return the value of the global destructor_count.
     */
    static long get_destructor_count();

    /**
     * Reset the values of the global counters.
     */
    static long get_assign_count();
    
    static void reset();

    /**
     * Overloaded == operator.
     * @return true if the values of two nodes are equal, else false.
     */
    bool operator ==(const Node&amp; other) const;

    /**
     * Overloaded &gt; operator.
     * @return true if the value of this node is greater than
     *              the value of the other node, else false.
     */
    bool operator  &gt;(const Node&amp; other) const;

private:
    long value;

    // Static member variables, which are global to the class.
    // These variables exist independently from any Node objects.
    static long constructor_count;
    static long copy_count;
    static long destructor_count;
    static long assign_count;
};

#endif /* NODE_H_ */
</pre>
<p class="caption">SortedList.cpp:</p>
<pre>#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include "SortedList.h"

using namespace std;

SortedList::SortedList()
{
    Node::reset();
}

SortedList::~SortedList()
{
    Node::reset();
}

int SortedList::size() const { return data.size(); }

bool SortedList::check()
{
    if (data.size() == 0) return true;

    list&lt;Node&gt;::iterator it = data.begin();
    list&lt;Node&gt;::iterator prev = it;

    it++;

    // Ensure that each node is greater than the previous node.
    while ((it != data.end()) &amp;&amp; (*it &gt; *prev))
    {
        prev = it;
        it++;
    }

    return it == data.end();  // Good if reached the end.
}

void SortedList::prepend(const long value)
{
    Node n(value);
    data.push_front(n);
}

void SortedList::append(const long value)
{
    Node n(value);
    data.push_back(n);
}

void SortedList::remove(const int index)
{
    list&lt;Node&gt;::iterator it = data.begin();
    for(int i = 0;i &lt; index;i++)
        it++;
    data.erase(it);
}

void SortedList::insert(const long value)
{
    list&lt;Node&gt;::iterator it = data.begin();
    while((it != data.end()) &amp;&amp; (it-&gt;get_value()&lt; value))
    {
        it++;
    }
    Node node(value);
    data.insert(it,node);
}

 list&lt;Node&gt; SortedList::j()
 {
    return data;
 }

Node SortedList::at(const int index)
{
    list&lt;Node&gt;::iterator it = data.begin();
    for(int i=0;i&lt;index;i++)
        it++;
    return *it;
}

/*bool SortedList::check_reversed() const
{
    if (size() == 0) return true;

    list&lt;Node&gt;::const_iterator it = data.begin();
    list&lt;Node&gt;::const_iterator prev = it;

    it++;

    // Ensure that each node is less than or equal to the previous node.
    while ((it != data.end()) &amp;&amp; (*it &lt;= *prev))
    {
        prev = it;
        it++;
    }

    return it == data.end();  // Good if reached the end.
}*/
</pre>
<p class="caption">SortedList.h:</p>
<pre>#ifndef SORTEDLIST_H_
#define SORTEDLIST_H_

#include &lt;list&gt;
#include &lt;iterator&gt;
#include "Node.h"

/***** Modify this file if necessary. *****/

using namespace std;

/**
 * A sorted linked list of Node objects.
 */
class SortedList
{
public:
    /**
     * Defaut constructor.
     * Reset the global Node counters.
     */
    SortedList();

    /**
     * Destructor.
     * Reset the global Node counters.
     */
    virtual ~SortedList();

    /**
     * @return the size of the data list.
     */
    int size() const;
   

    /**
     * Check that the data is sorted.
     * @return true if sorted, false if not.
     */
    bool check();

    /**
     * Return a forward iterator pointing at the indexed position.
     * @param index the index
     * @return the iterator.
     */
    list&lt;Node&gt;::iterator position(const int index);

    /**
     * Insert a new node at the beginning of the data list.
     * @param value the new node's value.
     */
    void prepend(const long value);

    /**
     * Append a new node at the end of the data list.
     * @param value the new node's value.
     */
    void append(const long value);

    /**
     * Remove a node.
     * @param index the index of the node to remove.
     */
    void remove(const int index);

    /**
     * Insert a new node into the data list at the
     * appropriate position to keep the list sorted.
     */
    void insert(const long value);

    /**
     * Return the data node at the indexed position.
     * @param the index of the node.
     * @return a copy of the data node.
     */
    Node at(const int index);
    list&lt;Node&gt; j();
    bool check_reversed() const;

private:
    list&lt;Node&gt; data;
};

#endif /* SORTEDLIST_H_ */
</pre>
<p class="caption">SortedVector.cpp:</p>
<pre>#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include "SortedVector.h"

using namespace std;

SortedVector::SortedVector()
{
    Node::reset();
}

SortedVector::~SortedVector()
{
    Node::reset();
}

int SortedVector::size() const { return data.size(); }

bool SortedVector::check() const
{
    if (data.size() == 0) return true;

    vector&lt;Node&gt;::const_iterator it = data.begin();
    vector&lt;Node&gt;::const_iterator prev = it;

    it++;

    // Ensure that each node is greater than the previous node.
    while ((it != data.end()) &amp;&amp; (*it &gt; *prev))
    {
        prev = it;
        it++;
    }

    return it == data.end();  // Good if reached the end.
}

void SortedVector::prepend(const long value)
{
    Node n(value);
    data.insert(data.begin(),n);
}

void SortedVector::append(const long value)
{
    Node n(value);
    data.push_back(n);
}

void SortedVector::remove(const int index)
{
    data.erase(data.begin()+index);
}

void SortedVector::insert(const long value)
{
    vector&lt;Node&gt;::iterator it = data.begin();
    while((it != data.end()) &amp;&amp; (it-&gt;get_value()&lt; value))
    {
        it++;
    }
    Node node(value);
    data.insert(it,node);

}
 vector&lt;Node&gt; SortedVector::j()
 {
    return data;
 }

Node SortedVector::at(const int index) const
{
    return data.at(index);
}

/*bool SortedVector::check_reversed() const
{
    if (size() == 0) return true;

    vector&lt;Node&gt;::const_iterator it = begin();
    vector&lt;Node&gt;::const_iterator prev = it;

    it++;

    // Ensure that each node is less than or equal to the previous node.
    while ((it != end()) &amp;&amp; (*it &lt;= *prev))
    {
        prev = it;
        it++;
    }

    return it == end();  // Good if reached the end.
}*/
</pre>
<p class="caption">SortedVector.h:</p>
<pre>#ifndef SORTEDVECTOR_H_
#define SORTEDVECTOR_H_

#include &lt;vector&gt;
#include &lt;iterator&gt;
#include "Node.h"

/***** Modify this file if necessary. *****/

using namespace std;

/**
 * A sorted vector of Node objects.
 */
class SortedVector
{
public:


    /**
     * Defaut constructor.
     * Reset the global Node counters.
     */
    SortedVector();

    /**
     * Destructor.
     * Reset the global Node counters.
     */
    virtual ~SortedVector();

    /**
     * @return the size of the data vector.
     */
    int size() const;

    /**
     * Check that the data is sorted.
     * @return true if sorted, false if not.
     */
    bool check() const;

    /**
     * Insert a new node at the beginning of the data vector.
     * @param value the new node's value.
     */
    void prepend(const long value);

    /**
     * Append a new node at the end of the data vector.
     * @param value the new node's value.
     */
    void append(const long value);

    /**
     * Remove a node.
     * @param index the index of the node to remove.
     */
    void remove(const int index);

    /**
     * Insert a new node into the data vector at the
     * appropriate position to keep the vector sorted.
     */
    void insert(const long value);

    /**
     * Return the data node at the indexed position.
     * @param the index of the node.
     * @return a copy of the data node.
     */
    Node at(const int index) const;
    
  vector&lt;Node&gt; j();
  bool check_reversed();
    

private:
    vector&lt;Node&gt; data;
};

#endif /* SORTEDVECTOR_H_ */
</pre>
<p class="caption">TestSuite.cpp:</p>
<pre>#include &lt;string&gt;
#include "SortedVector.h"
#include "SortedList.h"
#include "Node.h"

using namespace std;

// How many times to do gets.
const int GETS_COUNT = 10000;

void vector_prepends(SortedVector&amp; sv, const int size)
{
    /***** Complete this function. *****/
    for(int i = size;i&gt;0;i--){
        sv.prepend(i);
    }
}

void list_prepends(SortedList&amp; sl, const int size)
{
    /***** Complete this function. *****/
    for(int i = size;i&gt;0;i--)
        sl.prepend(i);

}

void vector_appends(SortedVector&amp; sv, const int size)
{
    /***** Complete this function. *****/
    for(int i = 0;i&lt;size;i++)
        sv.append(i);
}

void list_appends(SortedList&amp; sl, const int size)
{
    /***** Complete this function. *****/
    for(int i = 0;i&lt;size;i++)
        sl.append(i);
}

void vector_gets(SortedVector&amp; sv, const int size) throw (string)
{
    // First fill the vector data.
    vector_appends(sv, size);
    Node::reset();

    // Loop to access nodes at random positions.
    for (int i = 0; i &lt; GETS_COUNT; i++)
    {
        int index = rand()% size;
        long value = sv.at(index).get_value();

        /***** Complete this function. *****/

        // Make sure we got the correct node.
        if (index != value) throw string("Vector data mismatch!");
    }
}

void list_gets(SortedList&amp; sl, const int size) throw (string)
{
    // First fill the list data.
    list_appends(sl, size);
    Node::reset();

    // Loop to access nodes at random positions.
    for (int i = 0; i &lt; GETS_COUNT; i++)
    {
        int index = rand()%size ;
        long value = sl.at(index).get_value();
        // long value = sl.at(i);

        /***** Complete this function. *****/

        // Make sure we got the correct node.
        if (index != value) throw string("List data mismatch!");
    }
}

void vector_removes(SortedVector&amp; sv, const int size)
{
    // First fill the vector data.
    vector_appends(sv, size);
    Node::reset();

    // Loop to remove a node at a random position
    // one at a time until the nodes are all gone.
    while (sv.size() &gt; 0)
    {
        int index = rand()%sv.size();
        sv.remove(index);

        /***** Complete this function. *****/
    }
}

void list_removes(SortedList&amp; sl, const int size)
{
    // First fill the list data.
    list_appends(sl, size);
    Node::reset();

    while (sl.size() &gt; 0)
    {
        int index = rand()%sl.size();
        sl.remove(index);

    }
}

void vector_inserts(SortedVector&amp; sv, const int size)
{
    while(sv.size()&lt; size)
    {
        long int temp = rand();
        sv.insert(temp);
    }
}

void list_inserts(SortedList&amp; sl, const int size)
{
    while(sl.size()&lt; size)
    {
        long int  temp = rand();
        sl.insert(temp);
    }
}
void vector_reverse(SortedVector&amp; sv, const int size)
{
   
    // First fill the vector data.
    vector_appends(sv, size);
    Node::reset();
    
  //  Node *ptr=sv.j();
 vector&lt;Node&gt; x = sv.j();
    /***** Complete this function. *****/
   int i=1; 
 vector&lt;Node&gt;::iterator it=x.begin();
 it++;
 
 while(i&lt;size)
 {
    int v = sv.at(i).get_value();
    sv.prepend(v);
    it++;
    sv.remove(i);
    i++;
    
 }
    
  /* if (!sv.check_reversed()) throw("Vector reverse sort error!");*/
}
void list_reverse(SortedList&amp; sl, const int size)
{
     // First fill the list data.
    list_appends(sl, size);
    Node::reset();
 list&lt;Node&gt; x = sl.j();
    /***** Complete this function. *****/
       int i=1; 
 list&lt;Node&gt;::iterator it=x.begin();
 it++;
 
 while(i&lt;size)
 {
    int v = sl.at(i).get_value();
    sl.prepend(v);
    it++;
    sl.remove(i);
    i++;
    
 }
    
  
}
</pre>
<p class="caption">TestSuite.h:</p>
<pre>#ifndef TESTSUITE_H_
#define TESTSUITE_H_

#include "SortedVector.h"
#include "SortedList.h"

/***** Modify this file if necessary. *****/

/**
 * Test function: Insert new nodes at the beginning of the data vector.
 *                The final node data values are 0, 1, 2, ..., size-1.
 * @param sv the vector test subject.
 * @param size the data size of the vector.
 */
void vector_prepends(SortedVector&amp; sv, const int size);

/**
 * Test function: Insert new nodes at the beginning of the data list.
 *                The final node data values are 0, 1, 2, ..., size-1.
 * @param sl the linked list test subject.
 * @param size the data size of the linked list.
 */
void list_prepends(SortedList&amp; sl, const int size);

/**
 * Test function: Append new nodes at the end of the data vector.
 *                The final node data values are 0, 1, 2, ..., size-1.
 * @param sv the vector test subject.
 * @param size the data size of the vector.
 */
void vector_appends(SortedVector&amp; sv, const int size);

/**
 * Test function: Append new nodes at the end of the data list.
 *                The final node data values are 0, 1, 2, ..., size-1.
 * @param sl the linked list test subject.
 * @param size the data size of the linked list.
 */
void list_appends(SortedList&amp; sl, const int size);

/**
 * Test function: Access nodes in the data vector.
 * @param sv the vector test subject.
 * @param size the data size of the vector.
 * @throw an exception if anything goes wrong.
 */
void vector_gets(SortedVector&amp; sv, const int size) throw (string);

/**
 * Test function: Access nodes in the data list.
 * @param sl the linked list test subject.
 * @param size the data size of the linked list.
 * @throw an exception if anything goes wrong.
 */
void list_gets(SortedList&amp; sl, const int size) throw (string);

/**
 * Test function: Remove all the nodes from the data vector
 *                one at a time.
 * @param sv the vector test subject.
 * @param size the data size of the vector.
 */
void vector_removes(SortedVector&amp; sv, const int size);

/**
 * Test function: Remove all the nodes from the data list
 *                one at a time.
 * @param sl the linked list test subject.
 * @param size the data size of the linked list.
 */
void list_removes(SortedList&amp; sl, const int size);

/**
 * Test function: Insert random values into the sorted data vector.
 * @param sv the vector test subject.
 * @param size the data size of the vector.
 */
void vector_inserts(SortedVector&amp; sv, const int size);

/**
 * Test function: Insert random values into the sorted data list.
 * @param sl the linked list test subject.
 * @param size the data size of the linked list.
 */
void list_inserts(SortedList&amp; sl, const int size);

void vector_reverse(SortedVector&amp; sv, const int size) throw(string);
void list_reverse(SortedList&amp; sl, const int size) throw(string);
#endif /* TESTSUITE_H_ */
</pre>
</div>
<p class="header providedFiles">Provided files</p>
<div class="providedFiles">
<p class="caption">TestDriver.cpp:</p>
<pre>//SAMPLE

/**
 * Assignment #9. STL Vector vs. Linked List
 *
 * Compare the performance of the STL vector
 * vs. the performance of the STL linked list.
 * Discover hidden overhead.
 *
 * Author: Ron Mak
 *         Department of Computer Engineering
 *         San Jose State University
 */
#include &lt;iostream&gt;
#include &lt;iomanip&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#include &lt;chrono&gt;
#include "SortedVector.h"
#include "SortedList.h"
#include "Node.h"
#include "TestSuite.h"

using namespace std;
using namespace std::chrono;

/**
 * Run the test suite.
 * @throw an exception if anything goes wrong.
 */
void run_test_suite() throw(string);

/**
 * Run and time a pair of vector and linked list test functions.
 * @param test_name the name of the test pair.
 * @param fv the vector function.
 * @param fl the linked list function.
 * @throw an exception if anything goes wrong.
 */
void run_test_functions(const string test_name,
                        void fv(SortedVector&amp; sv, const int size),
                        void fl(SortedList&amp; sl,   const int size))
    throw(string);

/**
 * Run and time a vector test function.
 * @param sv the sorted vector test subject.
 * @param size the data size of the vector.
 * @param f the test function.
 * @return the elapsed time in milliseconds.
 * @throw an exception if anything goes wrong.
 */
long timed_test(SortedVector&amp; sv, const int size,
                void f(SortedVector&amp; sv, const int size)) throw(string);

/**
 * Run and time a linked list test function.
 * @param sl the sorted linked list test subject.
 * @param size the data size of the linked list.
 * @param f the test function.
 * @return the elapsed time in milliseconds.
 * @throw an exception if anything goes wrong.
 */
long timed_test(SortedList&amp; sl, const int size,
                void f(SortedList&amp; sl, const int size)) throw(string);

/**
 * Convert a number to a string with commas.
 * @param n the number.
 */
string commafy(const long n);

/**
 * Vector and list sizes.
 */
const int SIZES[] = {100, 500, 1000, 5000, 10000};

/**
 * The main.
 * Run the test suite and catch any exceptions.
 */
int main()
{
    srand(time(NULL));

    // The overall starting time.
    steady_clock::time_point start_time = steady_clock::now();

    // Run the test suite. Catch any exceptions.
    try
    {
        run_test_suite();
    }
    catch (string&amp; msg)
    {
        cout &lt;&lt; endl &lt;&lt; "***** " &lt;&lt; msg &lt;&lt; endl;
        cout.flush();
        return -1;
    }

    // Compute and print the overall elapsed time.
    steady_clock::time_point end_time = steady_clock::now();
    duration&lt;double&gt; elapsed_time = duration_cast&lt;duration&lt;double&gt;&gt;(end_time - start_time);
    cout &lt;&lt; "Done! Total time: " &lt;&lt; elapsed_time.count() &lt;&lt; " seconds" &lt;&lt; endl;

    return 0;
}

void run_test_suite() throw(string)
{
    run_test_functions("Prepend", vector_prepends, list_prepends);
    run_test_functions("Append",  vector_appends,  list_appends);
    run_test_functions("Get",     vector_gets,     list_gets);
    run_test_functions("Remove",  vector_removes,  list_removes);
    run_test_functions("Insert",  vector_inserts,  list_inserts);
    run_test_functions("Reverse", vector_reverse,  list_reverse);
}

void run_test_functions(const string test_name,
                        void fv(SortedVector&amp; sv, const int size),
                        void fl(SortedList&amp; sl, const int size))
    throw(string)
{
    // Print a nice header for the test pair.
    for (int i = 0; i &lt; test_name.length(); i++) cout &lt;&lt; "=";
    cout &lt;&lt; endl &lt;&lt; test_name &lt;&lt; endl;
    for (int i = 0; i &lt; test_name.length(); i++) cout &lt;&lt; "=";
    cout &lt;&lt; endl;
    cout &lt;&lt; "        |--------------------Vector-------------------|";
    cout &lt;&lt;       "  |---------------------List--------------------|" &lt;&lt; endl;
    cout &lt;&lt; "  Size      Time  Creates   Copies     Assigns Destroys";
    cout &lt;&lt;       "      Time  Creates   Copies     Assigns Destroys" &lt;&lt; endl;

    // Loop over the data sizes for the tests.
    for (int size : SIZES)
    {
        cout &lt;&lt; setw(6) &lt;&lt; commafy(size);

        // Run and time the vector test and print its statistics.
        SortedVector sv;
        //sv.reserve(size + 1);
        long etv = timed_test(sv, size, fv);
        cout &lt;&lt; setw(7)  &lt;&lt; commafy(etv) &lt;&lt; " ms";
        cout &lt;&lt; setw(9)  &lt;&lt; commafy(Node::get_constructor_count());
        cout &lt;&lt; setw(9)  &lt;&lt; commafy(Node::get_copy_count());
        cout &lt;&lt; setw(12) &lt;&lt; commafy(Node::get_assign_count());
        cout &lt;&lt; setw(9)  &lt;&lt; commafy(Node::get_destructor_count());
        cout.flush();

        // Run and time the linked list test and print its statistics.
        SortedList sl;
        long etl = timed_test(sl, size, fl);
        cout &lt;&lt; setw(7)  &lt;&lt; commafy(etl) &lt;&lt; " ms";
        cout &lt;&lt; setw(9)  &lt;&lt; commafy(Node::get_constructor_count());
        cout &lt;&lt; setw(9)  &lt;&lt; commafy(Node::get_copy_count());
        cout &lt;&lt; setw(12) &lt;&lt; commafy(Node::get_assign_count());
        cout &lt;&lt; setw(9)  &lt;&lt; commafy(Node::get_destructor_count());
        cout &lt;&lt; endl;
    }

    cout &lt;&lt; endl;
}

long timed_test(SortedVector&amp; sv, const int size,
                void f(SortedVector&amp; sv, const int size)) throw(string)
{
    // Starting time.
    steady_clock::time_point start_time = steady_clock::now();

    // Run the test.
    f(sv, size);

    // Compute and return the elpased time in milliseconds.
    steady_clock::time_point end_time = steady_clock::now();
    return duration_cast&lt;milliseconds&gt;(end_time - start_time).count();
}

long timed_test(SortedList&amp; sl, const int size,
                void f(SortedList&amp; sl, const int size)) throw(string)
{
    // Starting time.
    steady_clock::time_point start_time = steady_clock::now();

    // Run the test.
    f(sl, size);

    // Compute and return the elpased time in milliseconds.
    steady_clock::time_point end_time = steady_clock::now();
    return duration_cast&lt;milliseconds&gt;(end_time - start_time).count();
}

string commafy(const long n)
{
    string str = to_string(n);
    int pos = str.length() - 3;

    while (pos &gt; 0)
    {
        str.insert(pos, ",");
        pos -= 3;
    }

    return str;
}
</pre>
</div>
<p class="header score">Score</p>
<div class="score">
<p class="score">0</p>
</div>
<div class="footnotes"><div class="footnote">2018-04-06T00:17:49Z</div>
</div>
</body></html>
